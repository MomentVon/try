{
    "collab_server" : "",
    "contents" : "#Hochwasser Regulieren durch dynamischen Programieren\n##########################Parameter dynamiesche Progrmierung############\nconstMin=0.0\nconstMax=999.9\nconstBrech=-1.0\nvariblen=7  #Nutzeffekt, Entscheidungvariable, Zustandvariable Anfang, Zustandvariable End\n##########################Parameter Talsprren##############\ntotraum=11.0  #10^9m3\nvorhwbegrenzraum=26.0  #10^9m3\nnutzraum=29.8  #10^9m3\nhwschutzraum=30.0  #10^8m3\nganzraum=32.0 #10^8m3\nhwschutzraumabfmax=11.0  #10^m3/s\nganzraumabfmax=13.0  #10^m3/s\nfristhwanf=6  #MOnat, Juli\nfristhwend=9  #September\n##########################Parameter Hochwasser regieren#################\nhwdltat=3*3600  #s\nhwdltatvarible=3*3.6/100  #Masseinheit wechseln\nhwabfmax=22.0  #10^3m3/s\nhwabfmin=0.26  #10^3m3/s\nhwschrittn=24\nhwzustandvariblekl=vorhwbegrenzraum\nhwzustandvariblegr=35.0\nhwzustandvaribleprazision=0.1\nhwzustanddiskretn=floor(abs((hwzustandvariblekl - hwzustandvariblegr) / hwzustandvaribleprazision))\nHWZUFLUSS=array(scan(\"input/ihw.prn\"),dim = c(1,hwschrittn))/1000.0  #10^3m3/s\nHWWHDIS=array(seq(hwzustandvariblekl,constMax,by=hwzustandvaribleprazision),dim=c(hwzustanddiskretn))\nHWZUSTANDANF=array(26.0,dim=c(hwzustanddiskretn)) #10^8m3\nHWNUTZEFFEKANF=array(0,dim=c(hwzustanddiskretn))\n\n##########################Parameter Wasserkraft##################\nwkdltats=10*24*3600  #s\nwkdltath=10*24  #h\nwkwechsel1=3.6  #cl=q/wr(hsl) \nwkwechsel2=wkdltats/10^8 #Masseinheit wechseln\nwkabfmax=11000  #m3/s\nwkabfmin=200  #m3/s\nwkmincl=176  #MW 保证出力\nwkschrittn=36\nwkzustandvariblekl=totraum\nwkzustandvariblegr=nutzraum\nwkzustandvaribleprazision=0.3\nwkzustanddiskretn=ceiling(abs((wkzustandvariblekl - wkzustandvariblegr) / wkzustandvaribleprazision))\nwkfristhwanf=3*(fristhwanf-1)+1\nwkfristhwend=3*fristhwend\nWKCLXZ=read.table(\"input/xzcl.prn\",TRUE)  #st:m,ll:m3/s,cl:10^6W(MW),hsl:m3/kWh\nWKWSW=read.table(\"input/wsw.prn\",TRUE)  #ll:m3/s,wsw:m\nWKKRQX=read.table(\"input/krqx.prn\",TRUE)  #kr:m3,sw:m\nWKZUFLUSS=array(scan(\"input/iwk.prn\"),dim = c(1,wkschrittn))  #m3/s\nWKWHDIS=array(seq(wkzustandvariblekl,constMax,by=wkzustandvaribleprazision),dim=c(wkzustanddiskretn))\nWKZUSTANDANFANG=WKWHDIS  #10^8m3\nWKNUTZEFFEKANF=array(0,dim=c(wkzustanddiskretn))\n##########################Funktion andere kleine Tool#############\ninterpolation <- function(bktprm,BKTPRMLST,ZLPRMLST){\n  \n  n=length(BKTPRMLST)\n  if(bktprm < BKTPRMLST[1]){\n    zp=(bktprm - BKTPRMLST[1])*(ZLPRMLST[1] - ZLPRMLST[2])/(BKTPRMLST[1] - BKTPRMLST[2]+0.0000000001) + ZLPRMLST[1]\n    \n  }\n  if(bktprm > BKTPRMLST[n]){\n    zp=(bktprm - BKTPRMLST[n-1])*(ZLPRMLST[n-1] - ZLPRMLST[n])/(BKTPRMLST[n-1] - BKTPRMLST[n]+0.0000000001) + ZLPRMLST[n-1]\n    \n  }\n  if(bktprm >= BKTPRMLST[1]) {\n    for(i in 1:n){\n      if(bktprm < BKTPRMLST[i]){\n        zp=(bktprm - BKTPRMLST[i-1])*(ZLPRMLST[i-1] - ZLPRMLST[i])/(BKTPRMLST[i-1] - BKTPRMLST[i]+0.000000001) + ZLPRMLST[i-1]\n        break()\n      }\n    }\n  }\n  return(zp)\n}\n\n##########################Funktion Hochwasser#####################################################\nhwwasserhaltausgleichzustandwendfunk <- function(whanf,whend,ii){\n  return((whanf - whend + HWZUFLUSS[ii]*hwdltatvarible)/hwdltatvarible)\n}\n\ntausendjahrhwregierennutzeffkfunk <- function(VQVV){\n  VQVV[1]=max(VQVV[3],VQVV[4])\n  return(VQVV)\n}\n\nhwregierenurteilenfunk <- function(VQVV,ii=0){\n  vmax=VQVV[1]\n  v=VQVV[3]\n  q=VQVV[2]\n  if(q<hwabfmin){\n    return(constBrech)\n  }\n  if(v==constBrech){\n    return(constBrech)\n  }\n  if(v<hwschutzraum & q>hwschutzraumabfmax){\n    return(constBrech)\n  }\n  if((v>=hwschutzraum & v<ganzraum) & q>ganzraumabfmax){\n    return(constBrech)\n  }\n  if(v>=ganzraum  & q>hwabfmax){\n    return(constBrech)\n  }\n  else return(VQVV)\n}\n\ntausendjahrhwregierenzielfunk <- function(VQVVDIS,VORCONTROL){\n  for(i in 1:hwzustanddiskretn){\n    VQVVDIS[i,1]=ifelse(VQVVDIS[i,3]==constBrech,constMax,max(VQVVDIS[i,4],VORCONTROL[i]))\n  }\n  return(VQVVDIS[(which.min(VQVVDIS[,1])),])\n}\n##########################Funktion Wasserkraft############\nwkwasserhaltausgleichzustandwendfunk <- function(whanf,whend,ii){\n  return((whanf - whend + WKZUFLUSS[ii]*wkwechsel2)/wkwechsel2) ####\n}\n\nwknutzeffkfunk <- function(EQVV){\n  q=EQVV[2]\n  vanf=EQVV[3]\n  hwsw=interpolation(q,WKWSW$ll,WKWSW$wsw)\n  hanf=interpolation(vanf,WKKRQX$kr,WKKRQX$sw)\n  hst=hanf-hwsw\n  EQVV[5]=hst\n  hsl=interpolation(hst,WKCLXZ$st,WKCLXZ$hsl)\n  EQVV[6]=hsl\n  cl=q/hsl*wkwechsel1  #MW\n  clmax=interpolation(hst,WKCLXZ$st,WKCLXZ$cl)\n  cl=min(cl,clmax)\n  EQVV[7]=cl\n  EQVV[1]=max((cl*wkdltath),constMin) #MWh\n  return(EQVV)\n}\n\nwkregierenurteilenfunk <- function(EQVV,ii){\n  e=EQVV[2]\n  q=EQVV[2]\n  vanf=EQVV[3]\n  hwsw=interpolation(q,WKWSW$ll,WKWSW$wsw)\n  hanf=interpolation(vanf,WKKRQX$kr,WKKRQX$sw)\n  hst=hanf-hwsw\n  hsl=interpolation(hst,WKCLXZ$st,WKCLXZ$hsl)\n  cl=q/hsl*wkwechsel1  #MW\n  clmax=interpolation(hst,WKCLXZ$st,WKCLXZ$cl)\n  cl=min(cl,clmax)\n  \n  \n  if(vanf==constBrech){\n    return(constBrech)\n  }\n  if(ii >= wkfristhwanf & ii <= wkfristhwend & vanf > vorhwbegrenzraum){\n    return(constBrech)\n  }\n  if(cl<wkmincl){\n    return(constBrech)\n  }\n  if((vanf>=hwschutzraum & vanf<ganzraum) & q>ganzraumabfmax){\n    return(constBrech)\n  }\n  if(vanf>=ganzraum  & q>hwabfmax){\n    return(constBrech)\n  }\n  else return(EQVV)\n}\n\nwkregierenzielfunk <- function(EQVVDIS,VORCONTROL){\n  for(i in 1:wkzustanddiskretn){\n    EQVVDIS[i,1]=ifelse((EQVVDIS[i,3]==constBrech),constMin,(ifelse((EQVVDIS[,1]==VORCONTROL[]),EQVVDIS[i,1],(EQVVDIS[i,1]+VORCONTROL[i]))))\n  }\n  mark=max(EQVVDIS[,1])\n  if(sum(EQVVDIS[,1]==mark)==1){\n    markfolge=which.max(EQVVDIS[,1])\n  }\n  if(sum(EQVVDIS[,1]==mark)!=1){\n    markfolge=which.max(EQVVDIS[,4]*(EQVVDIS[,1]==mark))\n  }\n  return(EQVVDIS[markfolge,])\n}\n\n##########################HauptFunktion##########################\ndynamisheprogramierenfunk <- function(schrittn,zustanddiskretn,ZUSTANDANF,NUTZEFFEKANF,ZUSTANDDISKRET,zielfk,nutzeffekfk,zustandwendfk,urteilenfk){\n  CONTROL<- array(constBrech, dim=c(zustanddiskretn,variblen,schrittn))\n  for(i in 1:schrittn){\n    CONTROL[,4,]=ZUSTANDDISKRET\n  }\n  j=1\n  for(i in 1:zustanddiskretn){\n    TEM=array(constBrech,dim=c(zustanddiskretn,variblen)) \n    TEM[,3]=ZUSTANDANF #CONTROL[,4,j-1]\n    TEM[,4]=CONTROL[i,4,j] #\n    for(k in 1:zustanddiskretn){ #\n      TEM[k,2]=zustandwendfk(TEM[k,3],TEM[k,4],j) #\n      TEM[k,]=nutzeffekfk(TEM[k,])\n      TEM[k,]=urteilenfk(TEM[k,],j)\n    }\n    CONTROL[i,,j]=zielfk(TEM,NUTZEFFEKANF)#####\n    CONTROL[i,,j]=urteilenfk(CONTROL[i,,j],j)\n  }\n  \n  for(j in 2:schrittn ){\n    for(i in 1:zustanddiskretn){\n      TEM=array(constBrech,dim=c(zustanddiskretn,variblen)) \n      TEM[,3]=CONTROL[,4,j-1] #\n      TEM[,4]=CONTROL[i,4,j] #\n      for(k in 1:zustanddiskretn){ #\n        TEM[k,2]=zustandwendfk(TEM[k,3],TEM[k,4],j) #\n        TEM[k,]=nutzeffekfk(TEM[k,])\n        TEM[k,]=urteilenfk(TEM[k,],j)\n      }\n      CONTROL[i,,j]=zielfk(TEM,CONTROL[,1,j-1])#####\n      CONTROL[i,,j]=urteilenfk(CONTROL[i,,j],j)\n    }\n  }\n  return(CONTROL)\n}\n\nwegsuchen <- function(CONTROL,schrittn,zielfk){\n  BESTEND=zielfk(CONTROL[,,schrittn],CONTROL[,1,schrittn])\n  bestendzustand=BESTEND[4]\n  bestendnutzeffekt=BESTEND[1]\n  temmaker=bestendzustand\n  BESTWEG <- array(constBrech,dim=c(schrittn+1,variblen))\n  BESTWEG[schrittn+1,1]=bestendzustand\n  BESTWEG[schrittn+1,2]=bestendnutzeffekt\n  for(i in schrittn:1){\n    temmakerfolge=which(CONTROL[,4,i]==temmaker)\n    temmaker=CONTROL[temmakerfolge,3,i]\n    BESTWEG[i,]=CONTROL[temmakerfolge,,i]\n  }\n  return(BESTWEG)\n}\n\nkeismainfunk <- function(umkreisn,dynamisheprogramierenfunk,schrittn,zustanddiskretn,ZUSTANDANF,NUTZEFFEKANF,ZUSTANDDISKRET,zielfk,nutzeffekfk,zustandwendfk,urteilenfk){\n  CONTROLCONTROL=array(constBrech,dim=c(zustanddiskretn,variblen,schrittn,umkreisn))\n  BESTWEG <- array(constBrech,dim=c(schrittn+1,2,umkreisn))\n  \n  for(i in 1:umkreisn){\n    # minus=min(NUTZEFFEKANF[which(NUTZEFFEKANF!=constBrech)])\n    # NUTZEFFEKANF=NUTZEFFEKANF-minus\n    CONTROLCONTROL[,,,i]=dynamisheprogramierenfunk(schrittn,zustanddiskretn,ZUSTANDANF,NUTZEFFEKANF,ZUSTANDDISKRET,zielfk,nutzeffekfk,zustandwendfk,urteilenfk)\n    NUTZEFFEKANF=CONTROLCONTROL[,1,schrittn,i]\n    ZUSTANDANF=CONTROLCONTROL[,,schrittn,i]\n    if(length(which(ZUSTANDANF!=constBrech))==0){\n      print(\"tut mir leid\")\n      break()\n    }\n    BESTWEG[,,i]=wegsuchen(CONTROLCONTROL[,,,i],schrittn,zielfk)\n    if(i>1 & (sum((BESTWEG[,1,i]-BESTWEG[,1,i-1]))==0) ) {\n      \n      return(BESTWEG)\n    }   \n  }\n  return(BESTWEG)\n}\n\n##########################Funktion machen################\n# HWCONTROL=dynamisheprogramierenfunk(hwschrittn,hwzustanddiskretn,HWZUSTANDANF,HWNUTZEFFEKANF,HWWHDIS,tausendjahrhwregierenzielfunk,tausendjahrhwregierennutzeffkfunk,hwwasserhaltausgleichzustandwendfunk,hwregierenurteilenfunk)\n# HWWEG=wegsuchen(HWCONTROL,hwschrittn,tausendjahrhwregierenzielfunk)\n# AA1=dynamisheprogramierenfunk(wkschrittn,wkzustanddiskretn,WKZUSTANDANFANG,WKNUTZEFFEKANF,WKWHDIS,wkregierenzielfunk,wknutzeffkfunk,wkwasserhaltausgleichzustandwendfunk,wkregierenurteilenfunk)\n# AA2=dynamisheprogramierenfunk(wkschrittn,wkzustanddiskretn,AA1[,4,36],AA1[,1,36],WKWHDIS,wkregierenzielfunk,wknutzeffkfunk,wkwasserhaltausgleichzustandwendfunk,wkregierenurteilenfunk)\n# WKWEG2=wegsuchen(AA2,wkschrittn,wkregierenzielfunk)\n",
    "created" : 1517486639886.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1836038703",
    "id" : "783B9068",
    "lastKnownWriteTime" : 1517486698,
    "last_content_update" : 1517486698965,
    "path" : "F:/Documents/learngit/Rcode/dynamiescheprogramieren.R",
    "project_path" : "Rcode/dynamiescheprogramieren.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}